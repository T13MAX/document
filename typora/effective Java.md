# Effective Java

### 第一章 引言

### 第二章 创建和销毁对象

#### 第1条 用静态工厂方法代替构造器 

就是之前都直接new，现在提供一个静态的方法获取对象，跟单例似的。优点：有名称，有时候传相同的参数想获得不同的对象，调换顺序有点呆。有可能不是每次都创建一个新对象,可能是不可变对象,可能缓存起来，类似于单例，有时候创建对象开销大，还没用，有时候就想共享，有时候是事先准备好的，传就行了，布尔那个就跟享元模式似的。还可以返回子类对象，一个接口，返回一个特定的它的实现类的对象。返回的对象的类也可以根据传的参数变化，因为可以传各种子类，那根据参数不同想返回哪个返回哪个。返回的那个类，在我写这个静态方法的时候可以不存在，参考然后服务提供者框架，感觉很牛逼。缺点：不含有公有或受保护的构造器，就不能被子类化。静态方法不容易被发现。

#### 第2条 遇到多个构造器参数时考虑使用构建器(区别于构造器，应该是建造者的意思)

多个可选参数，有些参数不一定有没有，所以就在类里写一个静态Builder，把外部类的参数再写一遍，然后写各种静态方法，传什么玩意干啥事，返回当前对象，顺便还能检验参数，空惨构造+set方法就很麻烦，最后写一个build方法创建外部类对象，客户端就只需要调用Builder点什么点什么最后build就OK。多个构造器然后调来调去容易填错，而且要传不必要的参数，无参构造+set的方式无法保证一致性(我理解的就是万一这个对象还没set完，其他地方又干啥事了可能，和线程安全有关)。然后这个玩法也适用于类层次结构，上面的应该是对象，一个抽象类，有俩子类，子类的Builder是平行的，抽象类有个抽象self方法，子类重写返回this，原本的应该直接返回this，但是子类继承以后，还那么写返回的就不是子类对象，所以就调这个self方法，就可以保证能返回正确的子类对象。

#### 第3条 用私有构造器或枚举类型强化 Singleton公有域方法：

构造方法私有，final的引用创建一个对象，保证唯一性，防反射的方法是构造方法判断创建第二个直接抛出异常，优点是比较简单。静态工厂方法：上面的引用改为私有，提供一个公有方法获取单例，优点是更加灵活，可以看情况是不是单例，可以编写为泛型工厂，可以通过方法引用(就是：：俩冒号那个)。但是要想成为可序列化的光实现那个不行，因为序列化反序列化是弄一个新的，所以加一个readResolve方法。包含单个元素的枚举类型：不怕序列化，不怕反射，但是如果要继承一个类，那最好别这么玩。

#### 第4条 通过私有化构造器强化不可实例化的能  

一些工具类不希望被实例化，抽象化不行，因为可以子类化，默认会生成无参构造，所以就手动加一个私有的构造方法，里面直接抛出异常，避免在类内部不小心调用，永远不实例化。

#### 第5条 优先考虑依赖注入来引用资源 

一直这么玩，但是不知道讲了一堆啥，构造器往里传，还有用Spring，前面静态工具类和单例说的啥没看明白。

#### 第6条 避免创建不必要的对象

重用不会被修改的对象，String.matches开销大，因为创建Pattern对象，将正则表达式编译成有限状态机，把他做成静态域，第一次调用方法的时候创建，延迟初始化(不建议延迟初始化)，Map的keySet返回的就一直是同一个对象。自动装箱和拆箱也会创建多余的实例，尽可能少的创建，但是小对象提高清晰性和简洁性也OK。(看一下第50条保护性拷贝，重用对象代价更大，所以建新的，避免bug)

#### 第7条 消除过期的对象引用

这个栈的数组里的东西没删，其实没用了，但是还在引用(无意识的对象保持)，不光这个对象不被回收，他所引用的其他对象都不能被回收，清空对象引用是一个例外，而不是规范行为，大多数情况不需要手动指向null。一个类，自己管理内存，一个对象引用单元，而不是对象本身。缓存：有引用就有意义就用WeakHashMap，不好确定就专门整一个清除的后台线程，或者用LinkedHashMap，复杂的用java.lang.ref。监听器和其他回调：注册回调，没有显式取消注册，要用弱引用，例如WeakHashMap中的键。

#### 第8条 避免使用终结方法和清除方法finalizer(java8)，cleaner(java9)

清除方法没那么危险，但是依然是不可预测的，不能保证被及时执行(甚至都不一定被执行)，f和c是垃圾回收算法的一个主要功能，在不同的JVM运行表现截然不同。永远不要用f和c来更新重要的持久状态。终结方法报错打不出来，终结也会终止，清除方法没事。f和c还慢，f阻止了有效的垃圾回收，c稍微快点但是也慢，try with resources yyds。终结方法有安全问题，从构造器抛出异常，对象还存在(正常是不存在的)。用途：充当安全网，迟点关闭总比不关闭强，清除方法用于关闭本地对等体的资源，因为本地对等体不在gc范围内，但是如果必须及时终止或者性能需要，就应该有一个close方法。所以就是安全网，终止非关键的本地资源。总结:不使用清除方法，java9之前，尽量不用终结方法。

#### 第9条 try with resource优先于try finally

tf里嵌套tf，调用close也可能报错，第二个异常会抹除第一个异常，调试复杂。实现AutoCloseable接口(是要关闭的那个东东对应的类实现)，try(创建要关闭的对象){随便玩}，前面和close都报错，第二个错会被禁止，保留第二个，第二个也会显示，catch也能用，既可以抛出异常，又不用再套一层代码。

### 第三章 对于说有对象都通用的方法

#### 第10条 重写equals方法要遵守的通用约定

自反性，自己肯定得等于自己，对称性，x等于y，y也得等于x，传递性，x等于y，y等于z，那x也得等于z，一致性，x等于y，两者信息没被修改，那就永远相等，非空对象必定不等于null。传递性是因为子类扩展了父类，加了其他信息，两个父类一个子类之间的比较会出问题，最好的解决办法是不用继承，用组合，在equals方法里调用这个属性的eq方法。Timestamp和Date不能混用。不要用eq方法依赖不可靠资源，URL的IP地址就是反例，非空性用instanceof就行了。诀窍：==用来优化，先看看是不是自己，instanceof看类型，一般是判断调用eq的类，有时候是接口，比如集合类，转型，比较关键域，Float.compare比较快，eq要装箱，Double也是，要做特殊处理，因为Float.NaN，-0.0F，Object.eq可以避免空指针异常，Array.eq，用范式来降低开销。优先比较开销最低的，最容易不一致的，不比较不属于逻辑状态的域，例如Lock，不比较衍生域，除非是例如先比面积再比边长的那种，对称,传递,一致，哥仨很重要，因为自反非空通常自动满足。重写equals方法必须重写hashCode，不要在重写eq方法的时候把Object写成其他类型，那就成了重载了。

#### 第11条 重写equals方法必须重写hashCode

集合类很多都要调用hashCode，eq相等hc必须相等，hc相等eq可以不等，result=result*31+Integer.hashCode(a)，31是奇素数，可以i<<5-i，Object.hash传任意个参数，是数组，性能低，效果差不多。不可变类计算复杂的情况下可以记录下hashCode值，创建的时候初始化，或者第一次调用初始化，不要排除关键域来提高性能。

#### 第12条 始终要重写toString方法

不必须，但是提倡，打印的时候比较清晰，里面应该有所有的关键信息，这些信息要可以访问，否则解析字符串麻烦。值类，可以指定格式，标准明确，适合阅读，最好在配一个静态工厂或者构造器，方便在字符串和对象之间转换，不指定就保留了灵活性，未来可以修改。静态工具类的toS没有意义，枚举也不需要，子类共享通用字符串表示法的抽象类中要写，集合类的也都是从抽象类继承来的。

#### 第13条 谨慎的重写clone

感觉设计的很傻逼(不光我觉得)，clone是Object里的方法，但是你却要实现Cloneable接口，而这个接口里，啥都没有，只是在调用Object.clone的时候会判断你是否实现了，没实现抛出异常。返回的对象不能依赖被克隆的对象，Object的clone会逐域克隆，但是如果是一个引用，则克隆后还会指向那个对象，如果不用super.clone，而是new一个对象，那他的子类调的时候返回的就有问题，除非你用final修饰类，而且如果你还不用super.clone，那你实现克隆接口也没意义。不可变的类永远不该提供clone方法。可变对象就要递归调用，新建赋值。数组调clone好像很不错，但是如果数组是final，就不行。HashTable的私有类Entry提供一个深拷贝方法，循环深拷贝。也可以先调用super.clone，初始化，然后一点一点put进去，看着清晰但是慢，线程安全的类必须得到严格的同步。简单捋一遍，实现克隆接口，重写克隆方法，调用父类克隆方法，逐域修正，一般可变对象得递归调用克隆方法完成，基本类型一般不用管，但也有特例，比如id序号之类的。说了一大堆，全都是扯淡，我选择拷贝构造器或者拷贝工厂，构造器重载，传进去当前类的对象，返回一个克隆的对象，长得一模一样，但是是另一个对象，工厂就是构造器的变形，final域也不会冲突(clone方法给禁止final赋新值)，不会抛出受检异常，也不需要类型转换，甚至可以传参，参数类型是该类实现的所有接口，比如集合类都有拷贝构造器，参数类型为Collection或者Map接口，更准确的说已经是转换构造器和转换工厂了，允许客户选择拷贝的实现类型，而不是必须原始类型。虽然final的克隆实现类没危害，但是还是留到少数必要的情况在用吧，所以，除非是数组，否则为啥要用clone？？？

#### 第14条 考虑实现Comparable接口

实现这个接口，就具有内在的排序关系，java的所有值类，以及所有的枚举都实现了Comparable接口，返回的是正数0负数对应大于等于小于。一般希望compareTo为true那么equals也为true，compareTo只能同类型比较，否则抛出异常，违反hashCode的约定会破坏依赖散列的类，违反compareTo的就会破坏依赖比较关系的类，和eq差不多，自反性，对称性，传递性。cT和eq不一致，集合接口通用的是eq，而有序集合都用了cT，BigDecimal的1.0和1.00存在HashSet是俩，用的是eq，TreeSet是一个，用的是cT。比较的时候是顺序比较，而不是等同性比较，比较对象引用就递归调用cT，所有基本类型装箱类都有compare方法，比关系操作符好，多个关键域比较的顺序也很重要，应该产生非0结果直接返回，0就继续比较下一个。Comparator有比较器构造方法，lambda表达式，很牛逼往里传，构造一个比较器(再看看。

### 第四章 类和接口

#### 第15条 使类和成员的可访问性最小化

没啥东西，感觉就是讲了一下访问权限的问题，一个类，要隐藏其内部数据和其他实现细节，把API和实现清晰的隔离开来，组件之间通过API进行通信，也就是信息隐藏(封装)，封装的目的是为了解耦，降低各组件之间的耦合关系，使组件可以独立开发测试优化使用修改，加快开发速度，降低维护成本。其实就是更加独立，提高可重用性。public和protected都是包导出的API的一部分，就要永远支持他，private和包级私有，他就是实现的一部分，可以进行修改替换删除，如果一个类只在一个类的内部被用到，就要考虑使它成为私有嵌套类，私有和包级私有是实现的一部分，重点是导出API和实现之间的区别，实现序列化接口，有可能被泄露到导出API中(因为啥看86，87条)。子类重写后的访问级别必须高于父类，因为要保证任何使用父类的地方可以使用子类，(里氏替换原则)，一个类实现接口，则全为公有的。公有类的实例域绝不能是公有的，非final或者是final的可变对象的引用，则会失去对值限制的能力，包含公有可变域的类通常线程不安全，即使是final的不可变对象，也失去了灵活性(切换一种新的内部数据表示法)。长度非零的数组总是可变的，直接可取或者方法都不太好，所以应该让数组私有，提供一个不可变的集合的获取方法，或者clone一个数组也行(上回是不说clone唯一的优势就是数组来的)。总之就是能隐藏就隐藏，防止把乱七八糟的类接口成员变成API的一部分。

#### 第16条 要在公有类中使用访问方法而非公有域

说白了就是把属性全部私有化，然后提供get set方法，其实就是封装，域公有化了以后就不能改了，但是如果类是包级私有，或者私有嵌套类，则直接暴露和提供方法没区别，这样做反而更不容易产生视觉混淆。反例：java.awt.Pointer和Dimension，暴露内部数据造成了严重的性能问题(参考67条)，如果域是不可变的，危害会稍微小点，域被读取的时候无法采取辅助行动，但是可以强加约束(构造方法里)，总结，公有类不能暴露域，包级私有和私有可以。

#### 第17条 使可变性最小化

不可变类，实例不能被修改，所有信息在创建该实例的时候就提供，且整个生命周期内固定不变，例如String，BigInteger，BigDecimal，不可变类更加安全。五条规则：不要提供修改状态的方法，保证类不被继承，所有域都是final，所有域都是私有(域可能有对可变对象的引用)，确保对于任何可变组件的互斥访问(如果类具有指向可变对象的域，要确保类的客户端无法获得指向这些对象的引用，且不能使用客户端提供的对象引用来初始化，在构造器访问方法readObject方法中使用保护性拷贝(第50条))。函数的方法(返回的全是new一个对象)，与之对应的是过程的或者命令式的方法，名称用介词强调不会改变对象的值(点名批评BigInteger和BigDecimal)。不可变对象线程安全，不要求同步，可被自由共享，应鼓励重用现有实例，常用的提供一个公有静态的final常量，还可以提供静态工厂，整个缓存(表扬BigInteger)。不需要进行保护性拷贝，不需要提供clone或拷贝构造器(批评String)。甚至可以共享内部信息(？)，为其他对象提供大量构件(？)，提供了失败的原子性(？76条)，唯一缺点是每个不同的值都需要一个单独的对象。如果执行多步操作，每次新建对象，性能极差，BigInteger有一个包级私有可变配套类，但是无法预测要干啥奇怪的操作，就提供一个公有配套类(StringBuilder)。不非得不能被继承，也可以构造方法私有化，提供静态工厂，(再次点名批评那哥俩，不可变类必须为final)，不可信任的子类必须假设他可能是可变前提下进行保护性拷贝(50条)。域必须为final可以放宽，因为有些东西算完可以缓存起来，(hashCode)第一次被调用的时候计算，延迟初始化。一个序列化什么玩意参见88条。Date Pointer本应不可变，但却不是，较大的值做成不可变，小值也不可变。。？(啊这)。一些类可变，但是也要尽可能限制它的可变性，所以结合前面那章，要private final，还有个创建完只能使用一次的CountDownLatch，状态空间被设计的很小。

#### 第18条 复合优先于继承 

包的内部使用继承是安全的，因为子类父类在同一个人的控制之下，普通的具体类进行跨越包边界继承非常危险。继承破坏了封装性，因为子类依赖于父类中的实现细节，除非父类专门用来继承，否则实现发生变化，子类就会被破坏，HashSet的addAll依赖于add方法，这种自用性是实现细节，不是承诺，不能保证不变，要是完全重写也不太好，因为耗时易出错且无法访问父类私有域，父类添加其他方法也会导致子类出错。如果不重写，只添加新方法也不行，因为万一未来有个方法和你的名字一样返回类型不同，直接就无法通过编译。复合，转发666！新类添加一个私有域，现有类成为新类的一个组件，新类的方法调用现有类的方法，转发！不依赖于实现细节，现有类不管怎么玩也影响不到新类。一个类实现Set含有一个Set再被新类继承，(修饰者模式！！？)。包装类不适用于回调框架，(对象把自身引用传递给其他对象，用于后续调用)。只有庞庞是小狗这种才能用继承，(批评：Stack不该继承Vector，Properties不该继承Hashtable)，在该复合的地方使用继承，会暴露实现细节，这样的API会把你限制在原始的实现上，限定了性能，暴露了实现细节，客户端就可以直接访问细节。Propetties的getProperty和get，后一个方法继承自Hashtable，客户端直接修改父类，破坏子类的约束性，设计者想字符串，但是直接访问底层了。

#### 第19条 要么设计继承并提供文档说明，要么禁止继承 

被继承类要说明他可被重写的方法的自用性，公有的和受保护的方法或构造器要必须文档说明调用了哪些可重写的方法，调用顺序，调用结果如何影响后续处理过程。AbstractCollection，remove方法会受到iterator影响。写几个子类来测试，把用不到的私有化，发现实现不了就受保护。构造器不能调用可被重写的方法，父类构造器在子类构造器之前调用，如果父类构造器调用了子类重写的方法，而这个方法又依赖子类构造器的初始化，就傻呆呆了。被继承类实现Cloneable和Serializable，子类程序员要承受负担(13，86条)，为了允许继承，把实现细节变成API的一部分。禁止子类化，直接final或者构造器私有，使用静态工厂，禁止继承不方便？那就确保类永远不会调用可重写的方法，消除自用性。

#### 第20条 接口优于抽象类

接口想加就加，一个类只能有一个父类，如果两个类都想继承一个抽象类，那就要把抽象类放到类层次接口的高处，成为了祖先，间接地伤害到类层次，迫使这个公共祖先的所有后代类都扩展了他。接口是适合定义混合类型，比如Comparable，就是允许任选的功能，被混合到主要功能中。接口允许构造非层次结构的类型框架，歌唱家本身也是作曲家，可以定义第三个接口，同时继承俩接口，在加点东东，而有n个属性，就可能2的n次方种组合，组合爆炸！抽象类只能被继承，接口可以安全的增强类的功能，可以缺省方法提供协助(协助很有限)，不允许为Object的eq hC提供缺省，不允许包含实例域或非公有静态成员，给接口提供一个抽象的骨架实现类，把抽象类和接口的优点结合起来：接口定义类型，还可提供一些缺省方法，骨架实现类负责实现基本类型接口方法之外的非基本类型接口方法，铛铛铛挡，模板方法模式！！！名为AbstractInterface，例如AbstractList，AbstractCollection，内部类扩展骨架实现类，模拟多重继承。过程：研究接口，确定哪些方法最为基本，其他方法根据他们来实现，基本方法成为抽象方法，在基本方法之上实现的提供缺省方法，不能为Object的方法提供缺省方法，如果加一块覆盖了接口，就不需要骨架实现类了，否则，写个类，实现接口，实现剩下的所有方法，可以包含非公有的域。还有个简单实现，(骨架实现类再看看)。总之，接口用来定义多个实现，写了一个重要的接口，就提供一个骨架实现类，通过缺省方法提供骨架实现，对接口的限制，通常也使骨架实现会使用抽象类的形式。

#### 第21条 为后代设计接口 

尽量别往接口里加新方法，虽然能写成缺省的，不报错，但是缺省虽然通用但是不一定适用所有。有了缺省方法，就不会出现编译时没事运行却失败的情况。尽量不加，加也要考虑是否会破坏现有接口。缺省方法不能删除方法，也不能改名。

#### 第22条 接口只用于定义类型

如果一个类实现接口，接口就充当可以引用这个类的实例的类型，类实现了接口，就表明要对这个类实施某些动作，常量接口是对接口的不良使用，类内部使用某些常量，这是实现细节，但是接口会把这些暴露到API中，它代表一种承诺，以后类不需要这些常量了，依然必须实现这个接口，以确保二进制兼容性，如果类还是非final，那所有子类都会被污染。导出常量的合理方法是：如果常量和某些类或接口紧密相关，就应该把常量加到类或接口中，比如Integer和Double都有MIN_VALUE和MAX_VALUE，如果最好被看做枚举类型，就应该用枚举，否则就要使用不可实例化的工具类，大量用到工具类的常量，可以使用静态导入。(java7开始，数字可以用下划线隔开)

#### 第23条 类层次优于标签类 

标签类就是一个枚举，定义几个形状，一个标签，指明当前对象是啥形状，然后定义一大堆乱七八糟的域，计算面积也要看是啥标签。冗长，易出错，效率低下，应该一个抽象类形状，有面积抽象方法，如果有公共的域也要放进去，然后圆矩形都继承，都定义自己的域，重写面积方法，正方形继承矩形，直接super(side，side)。

#### 第24条 静态成员类优于非静态成员类 

非静态成员类都含有一个外围类的引用(可能造成内存泄露)，如果嵌套类可以在外围类的实例之外单独存在，那就必须是静态成员类，外围类的实例调用非静态成员类的构造器时，关联关系被建立，且不能修改，占用空间，增加构造时间。Map接口使用非静态成员类来实现他们的集合视图，keySet，entrySet，values返回的，如果成员类不要求访问外围实例，就应该是静态的，Map的Entry中的方法不需要访问Map，所以是static修饰的，如果相关类是导出类的公有或受保护的，会成为导出API的一部分，不能修改。匿名内部类，局部内部类。

#### 第25条 限制源文件为单个顶级类

叭叭叭说了一大堆，就是一个java文件尽量别写一堆类，写就写静态成员类啥的，别整一堆顶级类。

### 第五章 泛型

#### 第26条 不使用原生态类型

就是嘎哈都加上泛型就完事了。原生态类型存在，是为了兼容老代码，不使用泛型不安全，泛型是原生态类型的子类型，List<String>可以传给List，但是不能传给List<Object>，不能将null之外的任何元素放入Collection<?>。例外：类文字中使用原生态类型，List.class合法，List<?>.class，List<String.class>非法，instanceof的时候也不能带泛型。

#### 第27条 消除非受检的警告 

要尽可能消除每一个非受检警告，如果确认没问题就@SuppressWarnings("unchecked")，用的话也要尽可能缩小范围，弄到方法上，变量上最好，弄到类上纯属傻逼。写完注解还要写清注释帮助他人理解代码，减少修改代码导致不安全的概率。

#### 第28条 列表优于数组 

数组是协变的(Sub[]是Super[]的子类型)，泛型是可变的。往数组里存子类型合法但是运行报错，往List存非泛型参数直接编译报错。数组是具体化的，因此在运行时知道和强化他们的元素类型，泛型是通过擦除来实现的，编译时强化类型信息，运行时丢弃，数组和泛型不能混合使用。创建泛型数组非法，因为不是类型安全的。泛型一般不可能返回它的元素类型数组，结合可变参数方法(53条)，和泛型时会发出警告。(T[])强转不如用集合。

#### 第29条 优先考虑泛型

new  E[]不合法，因为不能创建不可不可具体化的类型的数组。两种办法，创建Object数组然后强转，会产生警告，因为编译器不可能证明程序是类型安全的，程序员确信没问题，就最小范围禁止警告，加个注解。第二种方法是把域就改成Object的数组，元素进行强转。第一种可读性高更常用，但是会导致堆污染，(第32条，数组运行时的类型与他编译时类型不匹配)。

#### 第30条 优先考虑泛型方法 

Collections中所有＂算法＂方法都泛型化了。union方法就传的俩集合，返回的集合加个泛型，同一种，利用有限制的通配符类型使方法变得更加灵活(第31条)。创建一个不可变但又适用于许多不同类型的对象，写一个工厂，给每个必要的类型参数分发对象:泛型单例工厂。例如Collections.reverseOrder。写一个恒等函数分发器(p117没太懂)。递归类型限制，通过某个包含该类型参数本身的表达式来限制类型参数是允许的。Comparable接口。
<E extends Cimparable<E>>读作:针对可以与自身进行比较的每个类型E。

#### 第31条 利用有限制通配符来提升API灵活性

List<String>不是List<Object>的子类型，泛型方法如果传一个子类就会编译报错，参数化类型是不可变的，生产者用<? extends E>，消费者用<？super E>，返回类型依然是E。Comparable和Comparator是消费者。需要用通配符支持那些不直接实现而是继承了实现接口的类型。如果类型参数只在方法声明中出现一次就可以用通配符取代，一个方法非得用通配符，写个私有的接类型？？？没事闲的。

#### 第32条 谨慎并用泛型和可变参数 

可变参数是个技术露底，会创建一个数组来存放，会产生警告，非具体化类型是指运行时代码信息比编译时少，当一个参数化类型变量指向不是该类型的对象时会产生堆污染，导致编辑器自动生成转换失败，破坏了泛型系统的基本保证。将值保存在泛型可变参数数组参数中是不安全的，显示创建泛型数组非法，但是可变参数泛型合法，因为泛型可变参数或参数化类型方法用处很大，忍了，Arrays.asList(T ... a)等等，这些方法还是安全的。使用@SafeVarargs禁止警告，不在数组中保存任何值，也不允许对数组的转义引用(导致不被信任的代码访问数组)，可变参数数组只用来将数量可变的参数从调用程序传到方法，那就是安全的。从来不在可变参数的数组中保存任何值，可能破坏类型安全性。允许另一个方法访问泛型可变参数数组是不安全的，传给另一个那个注解的方法安全，传给只计算属于内容部分函数的非可变参数方法也安全，总结两条:没有在可变参数数组中保存任何值，没有对不被信任的代码开放该数组。这个注解只能用在无法被覆盖的方法上，因为不能确保每个可能覆盖的方法都是安全的，只能静态或者final，java9私有实例方法也可。直接用List代替可变参数，慢一点麻烦一点。

#### 第33条 优先考虑类型安全的异构容器

充当参数化了的容器，限制容器只能有固定数目的类型参数，但是有时候想更灵活，例如数据库的行是任意数量的列，将键进行参数化，而不是容器，将参数化的键提交给容器来插入或获取值，String.class属于Class<String>类型，类的字面被用在方法中来传达类型信息被称作类型令牌，(C语言/n的时候Java用%n，产生适用于特定平台的行分隔符)。异构，不像普通的映射，所有的键都是不同类型。Map<Class<?>,Object>并不是不能把任何东西放进去，通配符类型是嵌套的，可以放进去任意类型的Class，异构就是从这里来的。值是Object，Map并不能保证值就是键所表示的类型，用Class的cast方法将对象引用动态的转换成Class所表示的类型(貌似不强转？只是检查是不是那个类型，是就原封不动的返回，不是就抛出异常)。但是如果使用原生态形式的Class就会破坏类型安全，就跟一般的集合实现一样，HashSet，HashMap，所以在put的时候就用cast检查一下(一些集合包装类就这么玩的，静态工厂属于泛型方法，确保Class对象和集合的编译时类型相匹配，在混有泛型和原生态类型中追溯是谁把错误的类型元素添加到了集合中)第二个局限是不能用List<String>.Class，他们都共用List.Class。Class<?>是无限制，也可以弄成有限制的，比如? extends Annotation，asSubclass方法调用Class对象转换成用其参数表示的类的一个子类，转换成功返回参数，失败抛出异常。集合使用泛型限制容器只能有固定数目的类型参数，把类型参数放到键上可避开这一限制，类型安全的异构容器用Class对象作为键，也可以定制键类型，用DatabaseRow表示一个数据库行容器，用泛型Column<T>作为键。

### 第六章 枚举和注解

#### 第34条 用enum代替int

枚举类型是由一组固定的常量组成合法值的类型，以前用int常量，不具备类型安全性，几乎没描述性，因为是编译时常量，所以十分脆弱，会编译到客户端中，如果改变，客户端要重新编译，很难打印字符串，不能遍历以及获得大小，还有个字符串常量，也不行，初级用户可能会把字符串常量硬编码到客户端代码。枚举:公有静态final域为每个常量导出一个实例，无可访问的构造器，final类，客户端不能创建实例也不能拓展，是受控的，是单例的泛型化，有隔离层，常量值在int枚举中没编译到客户端代码中，toString可打印名字，提供了Object的高级实现，实现了Comparable，Serializable接口，可添加方法和域。将数据与枚举常量关联起来，声明实例域，写一个构造器。枚举天生不可变，所以域为final。删除元素，没引用的没事，引用不重新编译就报错，编译会失败。如果枚举具有普遍性，就该成为顶层类，被用在特定类中就是成员类。将不同的行为与常量关联起来，switch傻呆呆，用抽象方法，如果添加常量，就不会忘记添加方法。除了编译时常量外，枚举构造器不可以访问静态域，因为构造器运行的时候，静态域还没初始化。特定于代码的方法共享代码困难了，switch不好维护，添加枚举常量的时候强制选择一个策略，策略设计模式！再写一个枚举，工作日，休息日，然后根据这个域来计算。枚举里的switch就用来给外部的枚举类型增加特定于常量的行为(Operation枚举不受我控制，加一个反运算)。枚举性能与int相当，装载和初始化需要空间和时间成本。需要一组固定常量，且编译时就知道其成员，枚举类型中的常量集并不一定始终保持不变。总结:枚举可读性好，更安全，功能强大，多个常量共享行为考虑策略枚举。

#### 第35条 用实例域代替序数 

枚举有个ordinal()方法，返回的是第几个(0开始)，但是别用这破玩意，直接写一个实例域，这个方法是给EnumSet和EnumMap这种基于枚举的通用的数据结构用的，除非是在写类似这种的结构，否则别用。

#### 第36条 用EnumSet代替位域 

用位运算把几个常量合并到一个集合中，称作位域。位域有很多缺点，遍历麻烦，确定长度，用int还是long。EnumSet有效的表示从单个枚举类型中提取多个值的多个集合。还有静态工厂快速创建对象。枚举类型要用在集合中，所以不需要用位域来表示，缺点是不能创建不可变的EnumSet。

#### 第37条 用EnumMap代替序数索引用

Enum.ordinal方法来索引数组或列表纯属傻呆呆，数组与泛型不兼容，未受检的转换，int值不能提供枚举的类型安全，使用错误的值，程序悄悄完成了错误的工作，或者角标越界异常。用EnumMap，安全，速度也不差，没有不安全的转换，索引不出错，有Map的功能。构造器是键的Class类型，是有限制的类型令牌。按照序数索引两次的数组更der(固液气，凝固，升华。。。)，二维数组表示什么状态，null表示没有，很呆，编译器不知道序数和数组的关系，过渡表出错，或者外面枚举发生变化里面的没更新，就会越界，空指针，还是用EnumMap，嵌套就行了，Map(起始阶段，Map(目标阶段，阶段过度))，一个阶段过度关联的两个关系，通过数据与过度枚举之间的关系获取。如果添加了新的状态，也就加阶段过度，几乎不会出错，提升清晰性，安全性，易于维护，空间或时间上也几乎没多余的开销，之前用null表示没变化也很呆。不用序数来索引数组，用EnumMap。

#### 第38条 用接口模拟可扩展的枚举 

枚举不能被继承，但是可以去实现一个接口，模拟扩展。一个Operation接口，写抽象方法，枚举实现，在每个枚举元素实现方法，枚举不能扩展，但是接口可以，可以写不同的枚举，实现不同的操作。不足:无法将实现从一个枚举类型继承到另一个枚举类型，如果实现代码不依赖任何状态，就可以把缺省实现放在接口中。Java中LinkOption枚举类型同时实现了CopyOption和OpenOption。总而言之，虽然不能扩展枚举，但是可以写枚举让他实现接口，可以让客户端写自己的枚举来实现接口。

#### 第39条 注解优于命名模式

JUnit4以前，得写testXXX，就很呆，拼错了也不知道，而且不能给程序传值，4开始用@Test。@Retention，@Target元注解。注解不会改变被注解代码的语意，使程序可以通过工具进行特殊处理，写一个方法，扫描带这个注解的方法，如果测试方法抛出异常，则InvocationTargetException，其中包括原始异常，有错误用法抛其他异常，方法里的异常被包含在反射异常里面。Class<? extends Throwable> values()，加了个参数，某个继承Throwable类的Class对象，允许用户指定一个错误类型，8之前都改成数组，且之前的单个元素的依然生效，8开始可以进行多值注解，用@Repeatable元注解对注解的声明进行注解，表示可被重复使用，有一个参数，包含注解类型的类对象，唯一的参数是注解类型数组。重复的注解会产生一个包含注解类型的合成注解，getAnnotationsByType会掩盖这一事实(？)，isAnnotationPresent重复的注解不是注解类型的一部分，而是所包含注解类型的一部分(就是好几个这个注解，用这方法一判断，发现没有)，检验是否存在，会忽略重复的注解，检验是否存在包含的注解，会忽略非重复的注解，所以必须检验注解和包含的注解类型。

#### 第40条 坚持使用@Override注解 

public boolean equals(Bigram b)没重写Object.equals，因为Object.equals(Object o)，所以要使用@Override注解。如果是一个没有标注的抽象类确定覆盖了父类的方法，可以不加，非抽象没覆盖就会编译报错。可以用在方法声明中，覆盖来自接口和类的声明，接口方法的具体实现上，如果没缺省方法，可以省略接口方法具体实现上的注解(说实话我不知道他在说啥)。抽象类或接口，需要标注，比如Set没有给Collection添加新方法，都加上，防止添加了。就是都加就完事了，覆盖了抽象声明方法可以不加，但是全加就完事了。

#### 第41条 用标记接口定义类型 

标记接口，不包含方法声明，只是指明一个类实现了具有某种属性的接口，比如Serializable接口，实现这个接口表明可被写到ObjectOutputStream中。标记接口定义的类型，是由被标记类的实例实现的，标记接口允许在编译时捕捉到 标记注解在运行时才能捕捉到的错误，但是序列化没利用这一点，序列化不可序列化的对象运行才会失败，标记接口可被更加精确的锁定，假设标记只适用于特殊接口实现，就可以用他将唯一接口扩展成他适用的接口，确保所有被标记的都是唯一接口的子类型(不懂，是不是通配符啊)，举例Set只适用于Collection。如果标记类之外的东西用注解，如果只标记类或接口，看一个还是多个只接受这种标记的方法，用接口作为相关方法的参数类型，如果不需要编写一个只接受带标记的对象，用注解。任何新方法都不会与之关联用接口，标记各种元素用注解。

### 第七章 Lambada和Stream

#### 第42条 Lambda优于匿名类 

用带有单个抽象方法的接口作为函数类型，实例被称为函数对象，表示函数或要采取的动作，J1.1以来只能用匿名内部类(著名的有策略模式)，J8开始，带有单个抽象方法的接口是值得特殊对待的，函数接口！用Lambda表达式创建这些接口的实例，(x,y->Integer.compare(x.length(),y.length()))，不需要写类型，因为编译器可以类型推导，但是某些情况下推不出来就要指定，26条不使用原生类型，29条支持泛型类型，30条泛型方法，然后就能推出来了，666啊，(原生类型可能直接无法编译)，用Lambda代替比较构造器更简单comparingInt(String::length)，34条枚举的四种类型重写抽象方法，也能简化，构造器直接传Lambda，然后那个方法直接调lambda，34条可知 枚举实例域优先于特定于常量的类主体，lambda让这个变得更容易了。lambda没名称没文档，主要是短，超过三行可读性低，传入枚举的参数是在静态环境计算的，lambda无法访问实例成员，如果枚举类型带有难以理解的特定于常量的行为，或者无法在几行之内实现，又或者要访问实例域或方法，那么特定于常量的类主体仍是首选。Lambda限于函数接口，匿名内部类可以创建抽象类的实例，多个抽象方法也可，Lambda无法获得对自身的引用，this指外围实例，匿名类指匿名实例。不要序列化lambda或匿名类实例，要序列化函数对象，如Comparator，要用私有静态嵌套类的实例，不要给函数对象使用匿名类，除非必须创建非函数接口的类型的实例。

#### 第43条 方法引用优先于Lambda 

map.merge(key,1,(count,incr)->count+incr)
merge就是没有就添加，有就递增，方法引用更简单map.merge(key,1,Integer::sum)，方法的参数越多，方法引用消除的样板代码就越多，但是有时候参数名提供了文档信息，可读性强，也可以从lambda提取代码，写个方法，然后引用这个方法。很多方法引用都引用静态方法，有四种例外:有限制，无限制的实例方法引用，两种构造器引用，分别针对类和数组。

#### 第44条 坚持使用标准的函数接口 

模板方法模式，子类覆盖基本类型方法，来限定父类的行为，der，提供一个接受函数对象的静态工厂或构造器，666，LinkedHashMap有个removeEldestEntry方法，如果重写，就可以用这个类当缓存，该方法返回true，就会删除最早存入的数据，这个方法调用调用size()，因为是映射中的一个实例方法，传到构造器的函数对象不是实例方法，无法捕捉，调用构造方法，映射还不存在，只能传自身，所以要传remove()(似懂非懂)，然后写了个函数接口，Map.Entry啥的。反正说了一大堆，要用人家写好的，尽量不新写，一共有6种，Operator代表结果与参数类型一致的函数，Predicate代表带有一个参数并返回boolean的函数，Function代表参数与返回值不一致的函数，Supplier代表没参数并且返回一个值的函数，Consumer不返回任何值。各自有三种变体，作用于基本类型int,long,double，在前面加就行了，Function有9种变体，SrcToResultFunction，然后返回也可能是对象，所以Result是Obj，然后这哥仨还都有俩参数的版本，BooleanSupplier。不能用包装类型，破坏了61条，有致命的性能问题。如果写仨参数或者抛出异常，要自己写，Comparator，通用，受益于描述性的名称，与其关联的严格的契约，收益于缺省方法，如果要写函数接口，要谨慎(21条)，还要使用@FunctionalInterface注解来标注，类似于@Override，告诉读者这是为了Lambda设计的，只有一个抽象方法才能编译，避免添加抽象方法。函数接口在API中的使用，不要在相同位置提供不同的函数接口来多次重载，否则可能引起歧义，看第52条。

#### 第45条 谨慎使用Stream

Stream流代表数据元素有限或无限的顺序，Stream pipeline是代表这些元素的一个多级运算，元素可以是对象引用，或者int long double三种基本类型。一个流管道有一个源Stream，接着是0个或多个中间操作和一个终止操作，中间操作会通过某种方式对Stream进行转换，比如映射到该元素的函数，过滤，中间操作都是从一个流转换成另一个流，元素类型可能和原来一样，也可能不同。流管道是lazy的，直到终止才会计算，没有终止操作的流管道是一个静默的无操作指令。一般按顺序执行，调用parallel可以并发执行，但是不建议(第48条)。找一个词典的同位词，流读进来，一个词一个词的看，先变成按字母排序的字符串，然后往Map里放，computeIfAbsent，是查找键，如果存在返回关键的值，不存在就会运用指定函数对象算一个值，将值与键关联起来，并返回该值。用流就是读取到一个流，然后弄到一个集合，分组，把值拿出来，过滤，就完事了，Java不支持char Stream，因为char也是数字，不强转打不出来字符，避免利用Stream处理char。代码块可以读取修改范围内的任意局部变量，lambda只能读取final，且不能改变local变量，代码块可以从外围方法中return，break continue外围循环，或者抛出异常，lambda不行。Stream可以统一转换元素序列，过滤，利用单个操作(添加，连接，计算最小值)合并元素，把元素放到一个集合中，比如根据某些公共属性分组，搜索满足条件的元素序列。一旦将一个值映射到某个其它值，原来的值就丢失了，解决办法是将每个值都映射到包含原始值和新值的对象对，但是不太行，最好的办法是将映射颠倒过来(不懂)。

#### 第46条 优先选择Stream中无副作用的函数

利用改变外部状态的频率表，在forEach的终止下完成，有点der，forEach在终止操作中最没威力，对Stream不友好，显示迭代，不适合并行，forEach应该只用于报告Stream计算的结果，而不是执行计算，有时也可以将计算结果添加到之前已经存在的集合中。应该用收集器collect，可以toList，toSet之类的，静态导入Collectors。comparing是一个比较器构造方法，freq::get，在频率表中查找单词，J9有Scanner的Stream方法，J8要用streamOf(Iterable)。toMap集合到映射中，一个键可关联一个或多个元素，最简单的带两个函数的一个映射键，一个映射值，多个值会报错，更复杂的用groupingBy，还有合并函数，BinaryOperator，三个参数的，最后一个是静态工厂方法maxBy生成比较器，取最大值，仨参数的可以发生冲突的时候保留最后更新，四个参数的是一个映射工厂，指定特殊的映射实现，如EnumMap，TreeMap。groupingBy返回收集器以生成映射，根据分类函数分门别类，还可指定下游收集器。可以传toCollection允许存各种集合，俩参数的groupingBy可以传counting作为下游收集器，计数。还可以指定映射工厂。groupingByConcurrent提供了三种重载变体，可以并发，还有partitioningBy，还有断言，返回Boolean的映射。counting只作用于下游收集器，Stream的count直接就行，所以coect(counting))是傻呆呆，还有summing，averaging，summarizing，然后reducing，filtering，mapping，flatMapping，collectingAndThen，(啥破玩意啊！！！)，Collectors有maxBy，minBy，joining(只在CharSequence实例的Stream中操作。(一大堆乱七八糟啥玩意啊)。

#### 第47条 Stream要优先使用Collection作为返回类型

J8以前，都返回集合或数组。现在如果用于for-each循环或者返回序列，无法用来实现Collection方法(一般是contains)，就用Iterable。如果返回基本类型或者有性能要求就用数组，但是现在Stream来了，要把Stream和迭代结合使用。给Stream的iterator方法传一个方法引用，有点乱，最好用适配器方法。Files的lines方法优于扫描器(Scanner)，因为后者吞掉了读取文件过程中的异常。Collection是Iterable的一个子类型，有一个stream方法，因此提供了迭代和stream访问，所以一般用Collection或者子类最好，数组也有Arrays.asList和Stream.of方法提供迭代和stream。别在内存中保存巨大的序列，将它作为集合返回，意思应该是返回一个专门的集合吧，就是有一个原集合，然后返回一个AbstractList，实现一些方法，比如get就是从原集合现取得。返回一个列表的所有子列表，太大，用Stream好点，前缀的后缀加空列表Stream.concat把空列表加入，flatMap生成一个包含所有前缀的所有后缀的Stream，IntStream.range和rangeCloseed返回连续的int值的Stream生成前缀和后缀，其实就是嵌套for循环来取，Stream-to-Iterable打乱了客户端代码，速度还慢，构建集合繁琐但是快。总结:能返回集合就返回集合，元素少就创建新集合(new一个标准集合)，否则定制集合，无法返回集合就返回Stream或Iterable。等Stream扩展了Iterable，就可以返回Stream了。

#### 第48条 谨慎使用Stream并行 

wait/notify内置了对线程的支持，J5引入了java.util.concurrent类库，提供了并行集合和执行者框架，J7引入fork-join包，处理并行分解的高性能框架，J8引入Stream，调用parallel实现并行处理。调用之后卡住不动(活性失败)，Stream类库不知道如何并行这个pipeline，不知如何探索失败，如果源头来自Stream.iterate，或者使用中间操作limit，也不会提升性能。并行提升性能最好用那些集合，数组，int范围和long范围等，共性是可被精确的分成任意大小的子范围(用分割迭代器)，spliterator方法返回。顺序处理时有引用局部性，引用的对象不挨着，线程会闲置，等数据从内存转移到处理器缓存，基本类型数组最牛逼，因为数据本身就挨着放在内存里。终止操作也会影响效率，最好用做减法，Stream的reduce方法，把元素合并到一起，或者预先打包min,max,count,sum之类的，骤死式操作，anyMatch,allMatch,noneMatch都可以并行，Stream的collect是可变的减法，不太好，合并集合成本高，自己编写就要重写spliterator方法。降低性能，活性失败，结果错误，安全性失败，可能是因为使用了映射，过滤器或者自己编写的其他函数对象，Stream的reduce操作的收集器函数和组合器函数，必须是有关联，互不干扰，无状态的。并行也有成本，不一定提速，看值不值得这么做(第67条)，都在一个通用的fork-join池运行，一个异常，就会损害系统其他不相关部分的性能。Random好像过时了，单线程用ThreadLocalRandom，SplittableRandom是专门并行的，有线性提速的可能，Random有同步，导致滥用。

### 第八章 方法

#### 第49条 检查参数的有效性

大多数方法和构造器对传给他们的参数都会有某些限制，方法体开头要检查参数，发生错误尽快检测出来，否则难以确定根源，可能导致违背失败原子性，用javadoc的@throws标签说明违反限制抛的异常。Object.requireNonNull也可以指定异常详情，会返回其输入。J9加入了Objects的三个检验方法。未被导出的方法，可以控制在哪些情况下被调用，确保参数有效，应该用断言检查参数，断言失败抛出AssertionError，如果没起到作用，不会有成本开销。参数本身不用，保存起来以后用，有问题都找不到在哪。有效性检查成本高或者隐含在计算中就完成了，比如排序的时候不能比较就抛出ClassCastException了(但是可能导致失败原子性)，异常和文档不一样可能需要异常转换(73条)，限制应该尽可能通用，越短越好。

#### 第50条 必要时进行保护性拷贝

记录一个时间段，start和end两个Date，构造方法虽然加了检验，但是客户端还拥有俩时间的引用，可以修改，J8开始用Instant或者LocalDateTime或ZonedDateTime，因为Instant是不可变类(Date已经过时)，为了避免内部信息受到攻击就要进行保护性拷贝，拿着传来的参数new一个新的给自己用，然后再检验参数，而不是针对原始对象，因为避免在危险阶段(从检查参数开始到拷贝参数)另一个线程改变类的参数，而且不能用clone因为不能保证返回的一定是Date对象，可能是子类。然后还要把get方法也进行保护性拷贝(new一个或者返回不可变视图，第15条)，不然又把引用返回给客户端了，可以用clone了，因为确信是Date类型(基于第13条，尽可能使用构造器或静态工厂)。传给Set和Map，再改，约束条件会被破坏。

#### 第51条 谨慎设计方法签名

谨慎设计方法的名称，就是起名要易于理解风格一致，参考Java类库的API。
不要过于追求提供便利的方法，只有被经常用到的时候才提供快捷方式。
避免过长的参数列表，四个以内，把方法分成多个方法，参考List的subList和indexOf和lastIndexOf，创建辅助类(PbPair？666啊)，可选参数用构建器，参数类型优先使用接口而不是实现类。
boolean参数优先使用枚举，可读性高，好拓展。

#### 第52条 慎用重载

重载形参为Set List Collection，然后创建一个Collection数组，添加这三种，并不会成功调用三个，而是全调用Collection的那个，因为调用重载方法是在编译时做出决定的，对重载方法的选择是静态的，对重写方法的选择是动态的(想想调用父类构造器而构造器调用了子类重写方法，而这个方法依赖子类初始化)，解决方法是写一个方法，用instanceof判断。安全而保守的办法是永远不要导出两个具有相同参数数目的重载方法，可变参数则永远不重载(除53条)，其实更简单的是起不同的名字，不用重载，writeInt，writeLong之类的，但是构造器咋整？第1条！写静态工厂啊！或者就是让两个参数是根本不同的类型，都不是对方的子类，比如ArrayList的一个构造器是int，一个是集合。List的remove方法因为没自动装箱为Integer，删坐标而不是元素，Lambda也有问题，不要在相同的参数位置调用带有不同函数接口的方法，如果重载的两个方法做的事结果一样就没事。

#### 第53条 慎用可变参数

可变参数放到数组里，有可能是空的，检验长度有点呆，第一个参数写第一个元素，后面是可变，但是创建数组性能堪忧，所以确定大多数情况三个以下就写五个重载，最后一个是可变，第一个是空，EnumSet就这么玩的(36条)，为位域提供了替代方法，primtf和反射经常用可变参数。

#### 第54条 返回空集合或数组而不是null

因为没有数据的情况不应该是特例，调用的人还要处理null就很麻烦，所以返回长度为零的集合，不会有太大的性能问题(67条)，也可以返回一个不可变的空集合，Collections.emptyList方法，永远不返回null而是返回一个长度为零的集合。

#### 第55条 谨慎返回Optional

在特定情况下可能无法返回任何值，要么抛出异常，要么返回null，异常会根据异常条件保留起来捕捉整个堆栈开销大，返回null开销低但是客户端必须包含特殊代码来处理null的可能性，Optional<T>是不可变容器。存放单个非null的T引用，或者啥也没有，Optional.empty()返回空的，Optional.of()返回一个非null的，null传进去是编程错误会空指针异常，ofNullable接受null，会变成empty()。Optional与受检异常类似，强迫用户面对没返回值的情况，orElse提供缺省值，orElseThrow抛出异常。(一些方法)。容器类型不该包装在Optional，不应该返回基本类型的Optional，有OptionalInt(还有lomg,double)，没(Boolean,Byte,Character)，Optional保存在实例域中？(第2条的可选那一堆)。总结:就是强迫用户每次调用都要考虑无法返回值的可能，但是更注重性能还是null，尽量别用作返回值之外的用途。

#### 第56条 为所有导出的API元素编写文档注释

没啥可写的啊

### 第九章 通用编程

#### 第57条 将局部变量的作用域最小化

跟第15条类似，将局部变量的作用域最小化，可以增强代码的可读性和维护性，要在第一次用的时候进行声明，局部变量声明应包含初始化表达式，没有足够的信息进行有意义的初始化就推迟这个声明，for循环优于while循环，因为while会在外面初始化，而for循环允许声明循环变量，迭代器的也能用for！优先用for-e，要调用remove才用fori(迭代器算fori)，也就是说只有不确定循环次数才用while，迭代器也要用for！！

#### 第58条 for-each循环优于传统for循环

fori的迭代器和索引变量会造成混乱，可能出错，fore没有性能损失，本质一样。嵌套的fori最里面调两个迭代器的next，最终不是N*N个结果，而是N个，因为在一次内层循环把外层的也都next完了，所以要在中间加一个变量，但是fore就没事还简洁。不能用fore:解构过滤，遍历删除元素，removeIf可以避免显式遍历，转换，遍历数组改变其中的值，平行迭代，遍历多个集合，所有的索引变量可以同步前进(和那个bug似的)。

#### 第59了解和使用类库

Random.nextInt()有缺陷，用nextInt(int)，划掉，谁还用Random啊！ThreadLocalRandom产生高质量随机数，而且快，如果是Frok Join Pool和并行Stream则使用SplittableRandom。看一下java.lang util io包的源码！

#### 第60条 精确答案避免使用float和double

float和double不准，用BigDecimal，有点不方便而且慢，弄String构造器不用Double避免传入不正确的值，自己处理小数点就用int,long。

#### 第61条 基本类型优于装箱基本类型

装箱类是引用，==是同一性比较，对装箱类用基本都是错的，装箱拆箱有性能问题，装箱类型还可能为null。泛型啥的必须用装箱类，但是能用基本类型就用基本类型。

#### 第62条 如果其他类型更合适，避免使用字符串

字符串不适合代替其他值类型，枚举类型(第34条)，聚合类型(字符串拼接)，能力表(不可伪造的键。

#### 第63条 了解字符串连接的性能

连接n个字符串需要n的平方级时间，用StringBuilder代替String。

#### 第64条 通过接口引用对象

51条是使用接口而不是类作为参数类型，应该是优先使用接口而不是类来引用对象，如果有合适的接口存在，参数，返回值，变量，域，都应该用接口声明。程序会更加灵活，更换实现也都OK，除非原来的实现提供了特殊的功能(PriorityQueue就有Queue没有的方法)。值类就用类而不是接口，final，很少有多个实现，很少有对应接口。

#### 第65条 接口优于反射机制

反射损失了编译时类型检查的优势，代码笨拙冗长，损失了性能。编译时类不可用，但是存在适当的接口，用接口来引用，用反射创建实例，Class<? extends Set<String>>来引用，66啊。

#### 第66条 谨慎的使用本地方法

JNI允许调用本地方法(本地编程语言C C++编写的方法)，提供了访问特定于平台的机制的能力，比如注册表，访问本地遗留代码库的能力，也可以编写注重性能的部分，但是不提倡。缺陷:本地语言不安全，不再能免受内存损坏错误的影响，本地语言与平台相关，所以不再可自由移植，难以调试，回收垃圾器不再是自动的。

#### 第67条 谨慎的进行优化

编写好的程序而不是快的程序，避免限制性能的决策，考虑API设计决策的性能后果。90%的时间花在10%的代码，优化可能导致性能更差，应该一开始就设计好，然后不优化，而且虚拟机多，平台多，不好权衡。

#### 第68条 遵守普遍接受的命名惯例

可被实例化的类或枚举用名词，不可实例化的工具类用复数，接口一般有able结尾，执行动作的方法用动词，boolean返回值的用is开头，转换对象类型用to什么，返回视图用as，返回对象同值的基本类型用typeValue，静态工厂用from,of,valueOf,instance,getInstance,newInstance,getType,newType，

### 第十章 异常

#### 第69条 只针对异常的情况才使用异常

try catch是在异常情况下使用的，不应该用在普通的控制流，用t c通过数组越界来终止循环，傻逼一样，异常机制用于不正常的情形，JVM没有进行中优化，t c反而阻止了本来可能要执行的优化，数组遍历不会导致冗余的检查，而且万一真的抛出异常了，结果也不知道。不应该让客户端为了正常的控制流而抛出异常，而是有状态相关的方法(比如hasNext)，也可以是Optional或可识别的返回值，如果被并发访问或者可以被外界改变状态则用后两个，如果方法必须重复状态相关方法的工作，应该用可识别返回值，其他情况用状态测试。

#### 第70条 对可恢复的异常使用受检异常，对编程错误使用运行时异常

受检异常强迫调用者用catch处理异常，运行时异常来表明编程错误，前提违例，没有遵守API规范建立的约定，所有未受检异常都是RuntimeException的子类，异常里的方法应该提供额外信息，引发这个异常的条件信息，用解析字符串不可移植，很脆弱，受检异常往往可恢复，所以要提供一些辅助方法，比如钱不够抛出受检异常，提供查询所缺费用的方法。

#### 第71条 避免不必要的使用受检异常

不同于返回码和未受检异常，受检异常强迫处理异常，增强了可靠性，抛出受检异常，必须在catch中处理，或者声明，然后让别人处理，都增加了负担，尤其J8的Stream中不能使用抛出受检异常的方法，消除受检异常的方法是返回零长度的Optional，但是不能提供额外信息，还可以分成两个方法，一个返回布尔值，表明是否抛出异常，等同于69条的状态测试，受检异常可以提高可读性，但是过度使用使使用API的人很难受，如果无法恢复失败，就抛出未受检异常，可恢复并且需要处理就optional，万一失败还需要提供信息就抛出受检异常。

#### 第72条 优先使用标准的异常

提倡重用代码，传的参数不合适的时候抛出IllegalArgumentE，对象的状态使调用非法抛出IllegalStateE，比如对象没初始化就调用了，大部分都是这两种，但是有些特殊情况比如空指针异常，角标越界异常，专门设计为单线程的对象或与外部同步机制配合使用的被并发修改就抛出ConcurrentModificationE，不支持所请求的操作UnsupportedOperationE，不应该重用Exception，RuntimeE，Throwable，Error。

#### 第73条 抛出与抽象对应的异常

更高层的实现应该捕获低层的异常，同时抛出可按照高层抽象进行解释的异常(称为异常转义)，低层是没有元素异常，高层捕获抛一个角标越界异常。低层的异常被传到高层，高层的异常提供访问方法获得低层异常(称为异常链)，高层构造器将原因传到支持链的超级构造器，最后传给Throwable。没有支持链的用initCause。但是异常转义也不能滥用，最好在调用低层方法之前确保他会成功执行，避免抛出异常，只有低层异常恰好对高层来说也是合适的，才把异常传播到高层。异常链允许抛出高层异常，同时又能捕获低层异常进行是失败分析。

#### 第74条 方法抛出异常要建立文档

单独声明受检异常，用javadoc的@throws记录每个异常的条件，不能写throws Exception，要单独声明每一个，throws不包含未受检异常。

#### 第75条 在细节消息中包含失败-捕获信息

导致抛出异常的参数和域的值应该被包含在异常的细节信息里(不要包含密码啥的)，比如角标越界异常，那个数非法了都会告诉你。

#### 第76条 努力使失败保持原子性

失败的方法调用应该使对象保持在被调用之前的状态。不可变类…(废话！)。提前检验参数，不检验大小直接pop会抛出异常，然后size变-1。调整顺序，让计算部分在对象修改之前发生，TreeMap要排序，插入的时候有问题直接类型转换异常。在对象的临时拷贝上进行操作，最后再把拷贝当结果返回，比如一些排序算法，即使失败，原数组也不变。编写恢复代码(不常用)，往往用于永久性的(基于磁盘的)数据结构。

#### 第77条 不要忽略异常

空的catch使异常达不到应有的目的，要忽略的话，应该在catch加注释，然后异常写成ignore，不管受检还是非受检异常，都不该忽略。有些可忽略，比如关闭FileInputStream，因为没改变文件的状态，不必执行恢复动作，无需终止正在进行的操作。

### 第十一章 并发

#### 第78条 同步访问共享的可变数据

 读或写一个非long或double的变量是原子的，但是不能保证一个线程写入的值对另一个线程是可见的，为了线程间可靠的通信，为了互斥访问，同步是必要的(java内存模型，一个线程所做的变化何时以及如何变成其他线程可见)。别用Thread.stop，阻止一个线程妨碍另一个线程，应该让第一个线程轮询一个布尔值，另个线程改变布尔值，普通的还不行，你得让他被看到，写一个读一个写的同步方法(必须读写都同步)，用volatile保证任何线程读取都能看见刚刚被写入的值，但是++不是原子的，只是能被看到，但是要+还没+的时候读了就会出错(安全性失败)，最好直接用AtomicLong类。一个线程短时间内修改一个数据对象，其他线程不同步也可以读取对象(对象称为高效不可变)，这个玩法称为安全发布，比如保存在静态域作为类初始化的一部分，保存在volatile，final域，或者并发集合。

#### 第79条避免过度同步

同步区域内，不要调用可被覆盖的方法，或者客户端以函数对象的形式提供的方法，外来的方法会导致活性失败和安全性失败。在遍历的时候想删除是非法的，如果另起一个线程则会死锁，主线程锁住，等线程完成删除，但是被锁了，线程无法获得锁。java的锁是可重入的，将外来代码移出同步就不会死锁了，并发集合直接拷贝整个底层数组，实现写操作，内部数组不改动，迭代不需要锁定。同步之外调用外来方法称为开放调用，增加了并发性，应该在同步内做尽可能少的事，尤其是耗时得事应该放外面，java.util的集合(除了Vector和HashTable)都省略了所有同步，需要同步就要使用的人在外部同步，java.util.concurrent的集合都是内部同步，使类成为线程安全。

#### 第80条 executor,task,stream优先于线程

工作队列，允许客户端按队列等待由后台线程异步处理的工作项目，ExecutorService类，用execute提交一个runnable，shutdown终止，等待一个任务或所有任务invokeAny,invokeAll,等待终止awaitTermination，调度特殊时间段运行或阶段运行利用ScheduledThreadPoolE，另一个静态工厂创建了线程池，可固定数目也可可变，最大限度控制用ThreadPoolE，小程序用newCachedThreadPool，不需要配置，大负载用newFixedThreadPool。使用线程时Thread即是工作单元，又是执行机制，E中是分开的，工作单元称为任务，有两种Runnable,Callable,(有返回值，可抛出异常)，J7支持fork-join任务，并发Stream就是在fork-join池编写的，可以被分为更小的子任务，提高cpu利用率。

#### 第81条 并发工具优先于wait和notify

现在都用并发工具了，谁还用wait和notify啊，并发工具有Executor Framework，并发集合，同步器(Synchronizer)，并发集合内部自己管理同步，锁定没卵用，通过依赖状态的修改操作，进行拓展，把几个基本操作合并到单个原子操作，String.intern必须使用弱引用，避免随着时间推移发生内存泄露，BlockingQueue通过阻塞操作进行拓展，一直等待到可以成功执行，可被用于工作队列,大多数ExecutorService都用了，同步器使线程能够等待另一个线程的对象，常用CountDownLatch，Semaphore，最强大的Phaser，CDL倒计数锁存器，int构造器，所有在等待的线程被处理之前必须调用countDown多少次(再看看吧！)。间歇式定时用nanoTime，比System.currentTimeMillis准，不受系统时钟影响。用wait循环模式来调用wait，不在循环外调用wait，等待之前测试条件，OK就不等了，之后测试，不OK接着等。优先用notifyAll唤醒。

#### 第82条 线程安全性的文档化

方法中出现Synchronized，是实现细节，不是导出API的一部分，不一定表明这个方法是线程安全的，所以文档有这个关键字就线程安全纯属放屁，而且要么全有要么全无得想法也是傻呆呆，线程安全有多种级别:不可变的(String，Long，BigInteger)，无条件的线程安全，这个类有足够的内部同步，有条件的线程安全，除了有些方法需要外部同步，其他与无条件相同，非线程安全，实例可变，并且需要外部同步，线程对立，不能安全的被多个线程并发使用，即使方法被外部同步包围，根源在于，没有同步的修改静态数据。有条件的线程安全要指明必须获得哪一把锁(极少数是几把)。使用公有可访问的锁对象意味着允许客户端以原子的方式执行一个方法调用序列，拒绝服务攻击，超时保持公有可访问锁，应该弄一个私有final的对象当锁，私有锁只能用在无条件线程安全类上，私有锁适合专门为继承而设计的类，因为子类可能会妨碍父类的操作，互相绊脚。

#### 第83条 慎用延迟初始化

大多数情况下，正常初始化要优于延迟初始化，使用同步方法访问，没值就初始化，对静态域延迟初始化就这么玩，对实例域就用双重检查(单例那个)，局部变量result，确保只在已经被初始化的情况下只被读取一次，能接受重复初始化就单重检查。不在意是否重新计算，并且是基本类型且不是long和double，可以不用volatile，

#### 第84条 不要依赖于线程调度器

依赖线程调度器一般就不可移植，应该保持线程的数量尽可能少，如果线程在做无意义的事就不该运行，不应该让线程处于忙-等的状态，即反复的检查一个共享对象，不要用Thread.yield来修正程序，也不要用线程优先级，因为这些都是靠影响调度器来那啥，优先级可以提高一个正常工作的质量，但是不会修正原本不正常的程序。

### 第十二章 序列化

#### 第85条 其他方法优于Java序列化

反序列化期间被调用的方法称为指令片段，多个一起是指令片段链，允许攻击者在底层硬件执行任意本机代码。长时间反序列化简短字节流就是拒绝服务攻击，称为反序列化炸弹。json基于文本，可阅读，protobuf是二进制的。永远不要反序列化不被信任的数据，不能确保安全性就用J9的反序列化过滤，白名单黑名单。

#### 第86条 谨慎的实现序列化接口

实现了序列化接口，它的字节流编码就变成了导出的API的一部分，默认的序列化形式会把私有和包级私有的实例域都变成导出API的一部分，以后改就可能不兼容，唯一标识符UID根据类名，实现的接口名，所有公有受保护方法生成，增加方法会破坏兼容性。新版旧版要保证序反成功，增加测试负担。BigInteger和Instant值类都实现了，活动实体的类没实现，比如线程池，为了继承而设计的类应该尽可能少的实现(只有Throwable和Component)，实例域值有约束条件，要防止子类覆盖finalize，被初始化为默认值必须添加readObjectNoData方法，内部类不应该实现，静态内部类可以。

#### 第87条 考虑使用自定义的序列化形式

一个对象的物理表示法等同于逻辑内容，可能就适合使用默认的序列化形式，要提供一个readObject方法保证约束关系和安全性。物理表示法和逻辑数据有实质性的区别，使用默认的序列化形式的缺点:导出的API永远束缚在类的内部表示法上，消耗过多的空间，时间，会引起栈溢出。writeObject和read前要先default，transient表明从默认序列化中省略，逻辑状态的一部分，域做成非瞬时的。读取整个对象状态的任何其他地方强制同步，对象序列化上也要强制同步。要加上UID，避免成为潜在的不兼容根源(第86条)。

#### 第88条 保护性的编写readObject方法

把readObject当成一个公有构造器，先保护性拷贝，再检验参数，但是就不能写成final了，检查失败抛InvalidObjectException，整个对象都要验证用ObjectInputValidation，不能调用可被重写的方法。

#### 第89条 对于实例控制，枚举优于readResolve

单例的话，序反出来的就不一样了，得加一个readResolve方法，返回INSTANCE来代替反序列化出来的对象，并且带有对象引用的实例域必须声明为transient。readResolve私有则不适用于任何子类，包级私有则同包子类，受保护或公有，则没重写它的子类，对子类反序列化会产生父类实例导致ClassCastException。

#### 第90条 考虑用序列化代理代替物理序列化实例

写一个私有静态内部类，把外部类的域复制一遍，然后外部类添加writeReplace，创建内部类对象，序列化产生的是内部类实例，然后外部类的readObject直接抛出异常，然后内部类readResolve创建外部类对象，而且允许外部类域是final的，不需要进行有效性检查。EnumSet就用了序列化代理。局限性是不能与客户端扩展的类相兼容，会类型转换异常，因为没对象，只有序列化代理，比保护性拷贝开销大一点点。

