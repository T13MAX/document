# Java并发编程实战



### 第一章 简介

计算机加入操作系统的原因: 资源利用率 公平性 便利性

线程优势: 发挥多处理器的能力 异步

线程带来的风险: 

1. 安全性 执行顺序不可预测 (永远不发生糟糕的事情)
2. 活跃性问题 比如无限循环 (正确的事情最终会发生) (死锁 饥饿)
3. 性能问题 希望正确的事情尽快发生 包括服务时间长 响应不灵敏 吞吐率低 资源消耗高 伸缩性低 

## 第一部分 基础知识

### 第二章 线程安全性

无状态一定是线程安全的

原子性 ++count并非原子(读取->修改->写入) 竞态条件 先检查后执行 延迟初始化 复合操作

加锁机制 多个字段 没保证同时修改 不变性条件中涉及多个变量 各个变量彼此不是独立的 某个值对其他值产生约束 需要同时更新

内置锁  同步代码块 

重入 获取锁的粒度是线程而不是调用 获取计数值和调用者线程 计数为零就释放

用锁来保护状态 要在访问这个变量的所有地方使用同步

活跃性与性能 简单性与并发性之间平衡 同步代码块也不能分的太细

### 第三章 对象的共享

如何共享和发布对象 安全的由多个线程同时访问

可见性 重排序

失效数据 获取失效值而不是随机值 这是最低安全性 ↓

非原子的64为操作 最低安全性适用大多数变量 非volatile的64为数值例外 JVM允许分解为两次32为的操作 不同线程的long和double会出问题

加锁与可见性 加锁不仅局限于互斥行为 还包括可见性

Volatile变量 将变量的更新操作通知到其他线程 不会被重排序 不会被缓存在寄存器或其他处理器看不到的地方 读取的时候总会返回最新写入的值

Volatile同场用作某个操作完成发生中断或者状态的标志

发布与逸出 发布最简单的就是保存到公有的静态变量 发布某个对象可能会间接的发布其他对象 发布一个内部类的实例会隐式发布外部类的对象

在构造方法创建线程没错 但是不要启动 构造方法调用一个可重写的实例方法也会导致this引用在构造过程中逸出

线程封闭 单线程内访问数据 JDBC的Connection对象返回之前不会被分配给其他线程 所以隐含地将Connection对象封闭在线程内

栈封闭 只能通过局部变量才能访问对象

ThreadLocal类 通常用于防止对可变的单实例变量或全局变量进行共享

不变性

安全发布 不正确的发布导致其他线程看到尚未创建完成的对象

### 第四章 对象的组合

设计线程安全的类

实例封闭 将数据的访问限制在方法上 监视器模式 使用私有的锁对象而不是对象的内置锁

线程安全性的委托 恩

在现有的线程安全类中添加功能 扩展方法比直接把代码加到类中更脆弱 底层类改变同步策略 子类会被破坏

添加一个原子操作来扩展类是脆弱的 一个类包含另一个类 把锁扩展到多个类中不好维护 破坏封装性



### 第五章 基础构建模块

同步容器类 Vector Hashtable 把状态封装起来 对公有方法进行同步 但是某些情况还是要额外的客户端加锁(一些复合操作: 迭代 跳转 条件运算(没有则添加))

迭代器与ConcurrentModificationException 及时失败 迭代过程中发现被修改直接抛 

里面加锁容易死锁 外面加锁长时间等待 降低可伸缩性 可以克隆容器(克隆过程要加锁)

隐式迭代器 标准容器的toString()将迭代 hashCode equals contains removeAll retainAll

并发容器 所有对容器状态的访问串行化 实现线程安全严重降低并发性 吞吐量降低

Queue 不会阻塞 队列为空返回空值ConcurrentLinkedQueue先进先出队列 PriorityQueue并发的优先队列 

BlockingQueue 队列为空 获取一直阻塞 队列已满 插入也一直阻塞 生产者-消费者设计模式中非常有用

ConcurrentHashMap 更细粒度的加锁机制实现更大程度的共享 分段锁 迭代器也不会抛内个异常 弱一致性 可以但不保证将迭代器被构造后的修改反映给容器 size isEmpty之类的都是估计值 只有程序要加锁Map进行独占访问时 才应该放弃使用ConcurrentHashMap 

ConcurrentHashMap 不能加锁来执行独占访问 无法新建原子操作(里面是分段锁 你外面加锁锁了个啥呀 傻呆呆)

CopyOnWriteArrayList 正确发布一个事实不可变对象 每次修改都发布一个新的容器副本 迭代器保留一个指向底层数组的引用 复制开销大 仅当迭代多于修改操作

阻塞队列和生产者-消费者模式 需要完成的工作和执行工作分离 把工作放入待完成列表 消除生产者与消费者之间的代码依赖性 解耦 线程池与工作队列的组合

LinkedBlockingQueue ArrayBlockingQueue PriorityBlockingQueue SynchronousQueue维护一组线程 直接交付

Deque BlockingDeque 双端队列

工作密取 每个消费者都有自己的双端队列 只访问自己的 不会竞争 然后去别人那从后往前

阻塞方法与中断方法 等IO 等锁 等Thread.sleep() 抛出Interrupted后 传递异常 处理异常Thread.currentThread().interrupt()

同步工具类 信号量 栅栏 闭锁

闭锁 延迟现成的进度直到其他到达终止状态 确保其他活动都完成后在继续执行 CountDownLatch  countDown方法递减 FutureTask通过Callable实现 异步任务 提前启动减少等待结果的时间 get会阻塞 闭锁是一次性对象 无法重置

信号量 计数信号量 控制同时访问某个特定资源的操作数量 执行某个特定操作的数量 对容器施加边界 不可重入 

栅栏 所有线程必须同时到达栅栏位置 闭锁用于等待事件 栅栏用于等待其他线程 CyclicBarrier使一定数量的参与者反复在栅栏位置聚集 迭代算法中常用 将一个问题拆分成相互独立的子问题 栅栏会被重置

缓存 放在ConcurrentHashMap<A,Future<V>>里 第一个来了就去计算 后面的阻塞get 防止重复计算 但是if也是并非原子的(先检查后执行)可能多个都进入if里 后面用putIfAbsent 防止重复放 Future可能导致缓存污染 计算被取消或者失败要移除 还要指定逾期时间 

## 第二部分 结构化兵法应用程序

### 第六章 任务执行



### 第七章 取消与关闭



### 第八章 线程池的使用



### 第九章 图形用户界面应用程序



## 第三部分 活跃性 性能 测试

### 第十章 避免活跃性危险



### 第十一章 性能与可伸缩性



### 第十二章 并发程序的测试



## 第四部分 高级主题

### 第十三章 显式锁



### 第十四章 构建自定义的同步工具

状态依赖性的类 等待队列进入非空或者任务进入已完成等 java的内置条件队列 显示的Condition AQS

单线程 条件将永远无法成真 状态会因为其他线程的操作而改变

内置条件队列使线程一直阻塞 直到对象进入某个进程可以继续执行的状态 可执行时在唤醒

异常应该用于发生异常得情况 红灯不是坏了

将失败传递给调用者 轮询+休眠 响应性和cpu使用率进行权衡

条件队列 条件谓词 加锁 wait和notify必须是一个锁

过早唤醒 丢失的信号 被劫持的信号

阀门类

显示Condition

 

### 第十五章 原子变量与非阻塞同步机制

非阻塞算法 底层的原子机器指令(比较并交换) 更高的可伸缩性和活跃性 不会受到单个线程失败的影响

锁: 通过使用一致的锁定协议来协调共享对象的访问,可以确保获得锁的线程独占访问这些变量,修改对随后获得锁的线程可见

挂起和恢复开销大 基于锁的类包含细粒度操作(同步容器类) 竞争激烈时 调度开销与工作开销比值很大

变量依赖其他变量 新值依赖旧值 不能使用volatile i++是三个独立操作

CAS V(内存位置) A(预期值) B(新值) 返回V**原有**的值

调用者处理竞争问题 性能随处理器数量不用而变化

JVM在底层硬件不支持CAS的时候用自旋锁

中低程度竞争下 原子变量提供更高的可伸缩性 高强度下 锁能够有效避免竞争

如果能避免共享状态 开销更小 提高处理竞争的效率提高可伸缩性 完全消除竞争才能实现真正的可伸缩性

饥饿 活锁 因为会反复重试

非阻塞链表

ABA 

### 第十六章 Java内存模型

编译器中生成的指令的顺序与源代码中的顺序不同 缓存会改变写入变量提交到主内存的次序 保存在处理器本地缓存的值对其他处理器不可见

可以提高执行速度 结果相同

在任意时刻都知道其他处理器正在进行的工作 开销大 适当放宽存储一致性保证 换取性能提升

每次读取都能获得最新写入的值 串行一致性

偏序关系

新对象的引用写入操作和各个字段的写入操作重排序 部分构造的对象 final可以保证没问题

java内存模型说明了某个线程的内存操作在哪些情况下对于其他线程是可见的



