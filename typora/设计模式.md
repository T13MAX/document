# 设计模式

## 创建型---------------------------------------------------------------------------------------------------------------------

### 工厂模式

#### 简单工厂

一个形状接口,三个形状实现,一个工厂,根据传入的type选择new什么

#### 工厂方法

把工厂抽象,为每个形状单独提供一个实现类,new对应的形状

#### 抽象工厂

有颜色形状两个东西,六个实现,工厂也有多种实现,提供不同的组合

### 单例模式

略

### 建造者模式

除了自己点点点最后build之外 也可以写好专门的组合 比如汉堡+饮料的组合

### 原型模式

每次都返回一个新的 clone

## 结构型---------------------------------------------------------------------------------------------------------------------

### 适配器模式

#### 类的适配器

继承源实现目标 最后出来的就是目标的东东

#### 对象的适配器

适配器拥有源实现目标

### 桥接模式

抽象和实现的分离

一个类有一个属性是某接口 可以传来这个接口不同的实现  然后调用出来的结果就不一样

### 代理模式

#### 静态代理

实现一个接口并存在一个这个接口的属性 然后实现方法 调用属性的方法 在前面后面可以执行自己的东西 这个属性对象是自己建的 不是传进来的

#### JDK动态代理

必须是有接口的 Proxy.newProxyInstance 接口类加载器 接口class 代理Handler 创建代理对象 Handler实现InvocationHandler重写invoke方法 代理对象调用任何方法都会那啥

#### CGLIB动态代理

实现MethodInterceptor重写intercept方法 用methodProxy调用invokeSuper(invoke无限递归) 再写一个获取实例的方法 Enhancer设置父类class设置callBack

通过这个方法获取代理对象

### 外观模式

隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口

### 装饰器模式

向一个现有的对象添加新的功能，同时又不改变其结构

实现一个接口并存在一个这个接口的属性 然后实现方法 在调用属性的时候能做一些其他操作

装饰器和代理的区别 代理是对某个对象代理 增强 这个对象自己建的 装饰器则是你给我啥 我装饰啥

### 享元模式

减少创建对象的数量

一个形状工厂 根据颜色存了一个Map 每次来了都去把以前的拿出来 没有就创建

## 行为型---------------------------------------------------------------------------------------------------------------------

### 模板方法模式

一个抽象类定义几件需要做的事 抽象方法 在写一个模板 按顺序执行这几件事 不同子类有不同的实现 都调用父类的执行

### 策略模式

一个类的行为或其算法可以在运行时更改 传入不同的实现,执行不同的方法

桥接模式包含策略模式

### 责任链模式

抽象日志类 三个实现类 是不同级别的日志 有一个字段是下一级别 每个都只记录大于自己级别的日志 然后在交给下一个

### 观察者模式

对象间存在一对多关系 一个啥玩意变化 要通知一堆对象 用List存 观察者存一个通知 通知有一个List放所有要通知的观察者

### 备忘录模式

保存一个对象的某个状态，以便在适当的时候恢复对象

